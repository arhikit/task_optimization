# Работа с памятью в Go

Задача: необходимо оптимизировать программу, с точки зрения использования памяти и скорости работы. Нельзя: менять структуру вызовов и саму логику работы приложения. Можно: менять аргументы, их типы и количество, инициализацию переменных и их использование.

Исходный код, требующий оптимизации, располагается в папке old. Общее время 10 тестов - **422.730s**. Файл old.txt. 
Количество аллокаций при одном запуске - **39 млн**. `go test -bench=BenchmarkGetTransformDocuments -benchmem -memprofile="./old/mem" -cpuprofile="./old/cpu" ./old`

**Вариант 1**. Папка new1.

Изменения:
1. Горутины для генерации документы. getDocumentsFromIntegration.

_Проблема_. В исходном программном коде для генерации каждого документа использовалась отдельная горутина. При большом количестве документов горутины чаще находились в блокировках, чем выполняли работу. Также была гонка из-за записи в общий слайс.

_Решение_. Для генерации документов я использовала отдельные долгоживущие горутины по количеству CPU. Общее количество документов разделила на количество cpu (1 млн нацело делится и на 4, и на 8, и на 16), получила общее количество запусков, выполняемое внутри горутины.
Также для того, чтобы не блокировать слайс документов для записи, каждая горутина пишет в свой выделенный сектор номеров.

2. Изменение документов. transformDocuments.

_Проблема_. При изменении документов создавался отдельный слайс и в него писались результаты трансформации.

_Решение_. Т.к. по коду нет явного указания, что слайс исходящих и входящих документов должны ссылаться на различные массивы, то выполнила трансформацию на исходном массиве документов.

Также изменила `for i := range documents` на `for i := 0; i < len(documents); i++`. По замерам второй вариант был быстрее.

3. Константы строк. const

Вынесла все строки в константы, чтобы точно все значения-строки указывали на общие данные. Ведь строка - immutable handle к значению. Соответственно, исключается возможное дублирование памяти для хранения одних и тех же данных.

**Итог**. Общее время 10 тестов - **60.704s**. Файл new1.txt. Количество аллокаций при одном запуске - **38 млн**.


**Вариант 2**. Папка new2.

Взяла вариант 1 и проводила изменения:
1. Генерация гуидов. uuid.New().

_Проблема_. Больше половины аллокаций связано с созданием uuid. Куча захломлена uuid-ами. 

Также при каждом обращении происходила генерация нового uuid, а хотелось бы заранее сгенерировать некоторое количество uuid-ов (например, 1000) и доставать их из пула по мере надобности.

_Решение_. Из библиотеки [github.com/google/uuid](url) забрала код по генерации uuid. Uuid убегал на кучу из-за использования в коде интерфейса Reader. 
Создала свою процедуру `newRandomFromPool()`. 

В процедуре использовала пул для хранения uuid. Изначально генерируется 1000 uuid, а затем по мере необходимости uuid-ы достаются, копируются и присваиваются нужным объектам. После расходования пула в него догружается новая порция uuid.
Для того, чтобы не блокировать пул mutex, на каждую горутину выделила свой пул с uuid-ами.

2. Использование append.

_Проблема_. При использовании append для добавления элементов в слайс, в случае если увеличивается емкость слайса, происходит аллокация нового массива удвоенного размера.

_Решение_. Т.к. размеры списков файлов и полей известны заранее, то сразу же создаю слайсы нужной емкости. Добавление элементов в слайс выполню по индексу.

**Итог**. Общее время 10 тестов - **18.819s**. Файл new2.txt. Количество аллокаций при одном запуске - **1.8 млн**. 

Общее время и количество аллокаций **уменьшилось более, чем в 20 раз** относительно исходного кода. 

**Нерешаемая проблема**.

К сожалению, полностью убрать аллокации на куче невозможно. Т.к. в кучу убегают массивы, связанные со слайсами. Ниже пример из файла example.go. Из которого видно, что если функция возвращает массив из 10 файлов, то хранение будет на стеке. Если же возвращаем слайс на этот же самый массив, то массив сразу убегает в кучу.

Т.к. в задаче нельзя было менять структуру данных, то и решить данную проблему, возникающую при генерации Document, не получится. При том, что сама сущность Document получается меньше 64Кб и могла бы храниться на стеке.

![example.go](https://github.com/arhikit/task_optimization/raw/main/doc/example.png)

**Изменения, которые не влияли**.

Пробовала также еще делать передачу по указателю параметров и результатов функций, но в данной задаче это только ухудшало и ни разу не улучшило быстродействие и производительность. 
<details><summary>Передача Document по указателю из transformDocuments в transformOneDocument</summary>

1 вариант. Передача Document по указателю. В transformDocuments по сущности Document возвращался указатель, указатель передавался в transformOneDocument (при передаче указатель также копируется) и в transformOneDocument по указателю возвращалась структура Document.
 
2 вариант. Передача сущности Document. Не было лишних операций по получению указателя и структуры по указателю и при передаче в процедуру копировалась сама сущность Document.

По производительности и времени данные 2 подхода равнозначны. Нет статистически значимых результатов улучшения времени работы.
</details>
